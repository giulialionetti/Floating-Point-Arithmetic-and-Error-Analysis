\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{enumitem}

\geometry{margin=2.5cm}

\pagestyle{fancy}
\fancyhf{}
\rhead{AFAE - Sorbonne Université}
\lhead{Computer Arithmetic Tutorial}
\rfoot{Page \thepage}

\tcbuselibrary{skins,breakable}

\newtcolorbox{notebox}[1][]{
  colback=blue!5!white,
  colframe=blue!75!black,
  title=Note,
  fonttitle=\bfseries,
  breakable,
  #1
}

\newtcolorbox{warningbox}[1][]{
  colback=red!5!white,
  colframe=red!75!black,
  title=Warning,
  fonttitle=\bfseries,
  breakable,
  #1
}

\newtcolorbox{successbox}[1][]{
  colback=green!5!white,
  colframe=green!75!black,
  title=Advantage,
  fonttitle=\bfseries,
  breakable,
  #1
}

\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  backgroundcolor=\color{gray!10}
}

\title{\textbf{Introduction to Computer Arithmetic}\\
\large Floating-point arithmetic and error analysis (AFAE)}
\author{Sorbonne Université}
\date{}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Exercise 1: Representation of Signed Integers}

\subsection{Question 1: Three ways to represent an 8-bit signed integer}

\subsubsection{Method 1: Sign-Magnitude}

\begin{itemize}
  \item \textbf{Format}: 1 bit for sign (0=positive, 1=negative) + 7 bits for magnitude
  \item \textbf{Range}: $-(2^7 - 1)$ to $+(2^7 - 1) = -127$ to $+127$
  \item \textbf{19}: \texttt{0001 0011} (sign=0, magnitude=19)
  \item \textbf{-19}: \texttt{1001 0011} (sign=1, magnitude=19)
\end{itemize}

\subsubsection{Method 2: One's Complement}

\begin{itemize}
  \item \textbf{Format}: Positive numbers as usual; negative numbers by flipping all bits
  \item \textbf{Range}: $-(2^7 - 1)$ to $+(2^7 - 1) = -127$ to $+127$
  \item \textbf{19}: \texttt{0001 0011}
  \item \textbf{-19}: \texttt{1110 1100} (flip all bits of 19)
\end{itemize}

\subsubsection{Method 3: Two's Complement (Most Common)}

\begin{itemize}
  \item \textbf{Format}: Positive numbers as usual; negative numbers by flipping bits and adding 1
  \item \textbf{Range}: $-2^7$ to $+(2^7 - 1) = -128$ to $+127$
  \item \textbf{19}: \texttt{0001 0011}
  \item \textbf{-19}: \texttt{1110 1101} (flip bits: 1110 1100, then add 1)
\end{itemize}

\begin{notebox}[title=Advantages of Two's Complement]
\begin{itemize}
  \item No duplicate zero
  \item Simpler arithmetic circuits
  \item Addition/subtraction use the same hardware
\end{itemize}
\end{notebox}

\section{Exercise 2: IEEE-754 Single Precision Representation}

\subsection{IEEE-754 Single Precision Format}

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
S & Exponent & Mantissa \\
1 bit & 8 bits & 23 bits \\
\hline
\end{tabular}
\end{center}

\textbf{Formula}: $(-1)^S \times 1.M \times 2^{E-127}$

\subsection{Number Representations}

\subsubsection{1. Number: 13}

\textbf{Binary conversion}: $13 = 1101_2 = 1.101_2 \times 2^3$

\begin{itemize}
  \item \textbf{Sign (S)}: 0 (positive)
  \item \textbf{Exponent (E)}: $3 + 127 = 130 = 10000010_2$
  \item \textbf{Mantissa (M)}: 101 followed by 20 zeros
\end{itemize}

\textbf{IEEE-754}: \texttt{0 10000010 10100000000000000000000}

\textbf{Hex}: \texttt{0x41500000}

\subsubsection{2. Number: 0.4375}

\textbf{Binary conversion}:
\begin{align*}
0.4375 \times 2 &= 0.875 \rightarrow 0 \\
0.875 \times 2 &= 1.75 \rightarrow 1 \\
0.75 \times 2 &= 1.5 \rightarrow 1 \\
0.5 \times 2 &= 1.0 \rightarrow 1
\end{align*}

$0.4375 = 0.0111_2 = 1.11_2 \times 2^{-2}$

\begin{itemize}
  \item \textbf{Sign (S)}: 0
  \item \textbf{Exponent (E)}: $-2 + 127 = 125 = 01111101_2$
  \item \textbf{Mantissa (M)}: 11 followed by 21 zeros
\end{itemize}

\textbf{IEEE-754}: \texttt{0 01111101 11000000000000000000000}

\textbf{Hex}: \texttt{0x3EE00000}

\subsubsection{3. Number: $-0.4375$}

Same as 0.4375 but with sign bit = 1

\textbf{IEEE-754}: \texttt{1 01111101 11000000000000000000000}

\textbf{Hex}: \texttt{0xBEE00000}

\subsubsection{4. Number: $1 + 2^{-24}$}

This is exactly representable in single precision!

$1 + 2^{-24} = 1.000000000000000000000001_2 \times 2^0$

\begin{itemize}
  \item \textbf{Sign (S)}: 0
  \item \textbf{Exponent (E)}: $0 + 127 = 127 = 01111111_2$
  \item \textbf{Mantissa (M)}: 23 zeros followed by 1 in the last position
\end{itemize}

\textbf{IEEE-754}: \texttt{0 01111111 00000000000000000000001}

\textbf{Hex}: \texttt{0x3F800001}

\subsubsection{5. Number: $1 + 2^{-24} - 2^{-25}$}

$= 1 + 2^{-25}(2 - 1) = 1 + 2^{-25}$

This cannot be exactly represented (mantissa only has 23 bits). The exact binary would need a 1 in position 25.

\textbf{Rounding to nearest}: This rounds to 1.0 (the $2^{-25}$ is below the precision)

\textbf{IEEE-754}: \texttt{0 01111111 00000000000000000000000}

\textbf{Hex}: \texttt{0x3F800000}

\subsubsection{6. Number: $1 + 2^{-24} + 2^{-25}$}

$= 1 + 2^{-25}(2 + 1) = 1 + 3 \times 2^{-25} = 1 + 1.5 \times 2^{-24}$

This is exactly halfway between $1 + 2^{-24}$ and $1 + 2 \times 2^{-24}$.

\textbf{Rounding to nearest (even)}: Rounds to $1 + 2 \times 2^{-24} = 1 + 2^{-23}$

\textbf{IEEE-754}: \texttt{0 01111111 00000000000000000000010}

\textbf{Hex}: \texttt{0x3F800002}

\subsubsection{7. Number: $1/7$}

$1/7 = 0.142857142857\ldots$ (repeating)

Converting to binary: $1/7 = 0.001001001001\ldots_2$ (repeating pattern: 001)

$= 1.001001001\ldots_2 \times 2^{-3}$

\begin{itemize}
  \item \textbf{Sign (S)}: 0
  \item \textbf{Exponent (E)}: $-3 + 127 = 124 = 01111100_2$
  \item \textbf{Mantissa (M)}: \texttt{00100100100100100100100}
\end{itemize}

\textbf{IEEE-754}: \texttt{0 01111100 00100100100100100100100}

\textbf{Hex}: \texttt{0x3E124925}

\begin{warningbox}
Note: $1/7$ cannot be exactly represented - it's a repeating binary fraction
\end{warningbox}

\subsubsection{8. Number: $2^{-130}$}

This is a \textbf{denormalized (subnormal) number} because the exponent would be $-130 + 127 = -3$, which is less than 0.

For denormalized numbers:
\begin{itemize}
  \item Exponent bits = 00000000
  \item Value = $(-1)^S \times 0.M \times 2^{-126}$
\end{itemize}

$2^{-130} = 2^{-126} \times 2^{-4} = 0.0001_2 \times 2^{-126}$

\begin{itemize}
  \item \textbf{Sign (S)}: 0
  \item \textbf{Exponent (E)}: 00000000 (denormalized)
  \item \textbf{Mantissa (M)}: 0001 followed by 19 zeros
\end{itemize}

\textbf{IEEE-754}: \texttt{0 00000000 00010000000000000000000}

\textbf{Hex}: \texttt{0x00080000}

\subsection{Question 2: Product of $a = 4097$ and $b = 8449$}

\textbf{Given}:
\begin{itemize}
  \item $a = 4097 = 2^{12} + 1 = 1.00000000001_2 \times 2^{12}$
  \item $b = 8449 = 2^{13} + 2^8 + 1 = 1.0000001000001_2 \times 2^{13}$
\end{itemize}

\textbf{Step 1: Represent $a$ in single precision}
\begin{itemize}
  \item Sign: 0
  \item Exponent: $12 + 127 = 139 = 10001011_2$
  \item Mantissa: \texttt{00000000001} + 20 zeros
\end{itemize}

\textbf{Step 2: Represent $b$ in single precision}
\begin{itemize}
  \item Sign: 0
  \item Exponent: $13 + 127 = 140 = 10001100_2$
  \item Mantissa: \texttt{0000001000001} + 18 zeros
\end{itemize}

\textbf{Step 3: Compute exact product}

\begin{align*}
a \times b &= (2^{12} + 1) \times (2^{13} + 2^8 + 1) \\
&= 2^{25} + 2^{20} + 2^{12} + 2^{13} + 2^8 + 1 \\
&= 2^{25} + 2^{20} + 2^{13} + 2^{12} + 2^8 + 1 \\
&= 34{,}603{,}009
\end{align*}

In binary: \texttt{10000100000011000100000001}$_2$

\textbf{Step 4: Normalize}

$= 1.0000100000011000100000001_2 \times 2^{25}$

\textbf{Step 5: Round to 23 bits (single precision)}

The mantissa has more than 23 bits. Keeping first 23 bits after the implicit 1: \texttt{00001000000110001000000}

Looking at bit 24: 0, and bit 25: 1. Since we need to round and bit 24 is 0, we round down (keep as is).

\textbf{Result $c$}:
\begin{itemize}
  \item Sign: 0
  \item Exponent: $25 + 127 = 152 = 10011000_2$
  \item Mantissa: \texttt{00001000000110001000000}
\end{itemize}

\textbf{IEEE-754}: \texttt{0 10011000 00001000000110001000000}

\textbf{Hex}: \texttt{0x4C080620}

\section{Exercise 3: Problem with Double Rounding}

\subsection{Given}

\begin{itemize}
  \item $x = 1.0110101000001001111001101111111111111100101011111110_2$
  \item $y = 1.1010100000001111111111111111111111111111111111111111_2 \times 2^{-39}$
\end{itemize}

\subsection{Question 1: Compute $x + y$ exactly}

Since $y$ is multiplied by $2^{-39}$, we need to align the exponents.

$x$ has exponent 0 (assuming normalized form with exponent bits decoded). $y$ needs to be shifted right by 39 positions to align with $x$.

\textbf{Exact sum}:

\begin{align*}
x &= 1.0110101000001001111001101111111111111100101011111110_2 \\
y &= 0.0000000000000000000000000000000000000001101010000000111\ldots_2
\end{align*}

Adding these together:

\begin{align*}
x + y &= 1.0110101000001001111001101111111111111110000101111111011\ldots_2
\end{align*}

The exact result has more than 53 bits of precision in the fractional part.

\subsection{Question 2: Rounding to double precision, then to single precision}

\textbf{Step A: Round $x + y$ to double precision (53-bit mantissa)}

The exact sum needs to be rounded to 53 bits after the binary point.

Looking at the 53 bits of mantissa: \texttt{0110101000001001111001101111111111111110000101111111011}\ldots

The 54th bit is used for rounding. Applying round-to-nearest:

\textbf{Double precision result}: $1.0110101000001001111001101111111111111110000101111111011_2$

After rounding, we keep 53 bits: \texttt{0110101000001001111001101111111111111110000101111111011}

\textbf{Step B: Round this double precision result to single precision (24-bit mantissa)}

Now we take the double precision result and round to 23 bits (+ 1 implicit bit).

Mantissa in double: \texttt{0110101000001001111001101111111111111110000101111111011}

Keep first 23 bits: \texttt{01101010000010011110011}

The 24th bit is 0, the 25th bit is 1, and there are more non-zero bits after. Since bit 24 is 0, we round down.

\textbf{Single precision result from double rounding}: $1.01101010000010011110011_2$

\subsection{Question 3: Direct rounding from exact sum to single precision}

Taking the exact sum and rounding directly to single precision (23-bit mantissa):

Exact: $1.0110101000001001111001101111111111111110000101111111011\ldots_2$

First 23 bits of mantissa: \texttt{01101010000010011110011}

Bit 24: 0, Bit 25: 1, Following bits: have 1's

For round-to-nearest with bit 24 = 0, we round down.

\textbf{Single precision result from direct rounding}: $1.01101010000010011110011_2$

\subsection{Observation}

\begin{warningbox}[title=Double Rounding Problem]
\textbf{Key insight}: Double rounding can produce different results than direct rounding when:

\begin{enumerate}
  \item The value is exactly halfway between two representable values at the intermediate precision
  \item The tie-breaking rule (round to even) at the intermediate precision affects the final result
\end{enumerate}

In this specific case, the bits after position 53 in the exact sum create a situation where:
\begin{itemize}
  \item Rounding to double precision first may round up
  \item Then rounding that double to single may go in a different direction
  \item Than directly rounding the original to single precision
\end{itemize}

\textbf{This demonstrates the ``double rounding problem'':}

Rounding a value twice (to intermediate then final precision) can give a different result than rounding directly to the final precision.

This is why FPU operations should avoid double rounding when possible.
\end{warningbox}

\section{Exercise 4: Computation of Square Root and Division}

\subsection{Question 1: Newton-Raphson for Square Root}

\textbf{Goal}: Compute $\sqrt{a}$

\textbf{Method}: Find the root of $f(x) = x^2 - a$

\textbf{Newton-Raphson formula}:
\begin{equation}
x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
\end{equation}

\textbf{Derivatives}:
\begin{itemize}
  \item $f(x) = x^2 - a$
  \item $f'(x) = 2x$
\end{itemize}

\textbf{Iteration formula}:
\begin{align*}
x_{n+1} &= x_n - \frac{x_n^2 - a}{2x_n} \\
&= x_n - \frac{x_n}{2} + \frac{a}{2x_n} \\
&= \frac{x_n}{2} + \frac{a}{2x_n}
\end{align*}

\textbf{Simplified}:
\begin{equation}
\boxed{x_{n+1} = \frac{1}{2}\left(x_n + \frac{a}{x_n}\right)}
\end{equation}

This is the classic formula for computing square roots!

\textbf{Example}: $\sqrt{2}$ with $x_0 = 1.5$

\begin{itemize}
  \item $x_1 = \frac{1}{2}(1.5 + 2/1.5) = \frac{1}{2}(1.5 + 1.333\ldots) = 1.4166\ldots$
  \item $x_2 = \frac{1}{2}(1.4166\ldots + 2/1.4166\ldots) = 1.4142\ldots$
  \item $\sqrt{2} \approx 1.41421356\ldots$
\end{itemize}

\subsection{Question 2: Convergence Rate}

Newton-Raphson has \textbf{quadratic convergence}: the number of correct bits approximately doubles at each iteration.

\textbf{Given}: $x_0$ has 4 bits of accuracy

\begin{center}
\begin{tabular}{cc}
\toprule
Iteration & Bits of accuracy \\
\midrule
0 & 4 \\
1 & $\approx$ 8 \\
2 & $\approx$ 16 \\
3 & $\approx$ 32 \\
4 & $\approx$ 64 \\
\bottomrule
\end{tabular}
\end{center}

\textbf{For 24 bits (single precision)}:
\begin{itemize}
  \item Start: 4 bits
  \item After iteration 1: $\approx$ 8 bits
  \item After iteration 2: $\approx$ 16 bits
  \item After iteration 3: $\approx$ 32 bits \checkmark
\end{itemize}

\textbf{Answer}: \textbf{3 iterations} needed for 24-bit accuracy

\textbf{For 53 bits (double precision)}:
\begin{itemize}
  \item Start: 4 bits
  \item After iteration 1: $\approx$ 8 bits
  \item After iteration 2: $\approx$ 16 bits
  \item After iteration 3: $\approx$ 32 bits
  \item After iteration 4: $\approx$ 64 bits \checkmark
\end{itemize}

\textbf{Answer}: \textbf{4 iterations} needed for 53-bit accuracy

\subsection{Question 3: Division using Newton-Raphson}

\textbf{Goal}: Compute $a/b$

\textbf{Method}: Instead of dividing, compute $1/b$ and then multiply by $a$.

\textbf{Find root of}: $f(x) = 1/x - b = 0$, which means $x = 1/b$

Alternatively, use $f(x) = b - 1/x = 0$

\textbf{Better formulation}: $f(x) = 1 - bx = 0$

\begin{itemize}
  \item This avoids division in the iteration itself!
  \item $f'(x) = -b$
\end{itemize}

\textbf{Newton-Raphson formula}:
\begin{align*}
x_{n+1} &= x_n - \frac{1 - bx_n}{-b} \\
&= x_n + \frac{1 - bx_n}{b}
\end{align*}

\textbf{Simplified}:
\begin{equation}
\boxed{x_{n+1} = x_n(2 - bx_n)}
\end{equation}

This formula computes $1/b$ using only multiplications and subtractions!

\textbf{Final step}: Once we have $1/b$, compute $a/b = a \times (1/b)$

\textbf{Algorithm}:
\begin{enumerate}
  \item Choose initial approximation $x_0 \approx 1/b$
  \item Iterate: $x_{n+1} = x_n(2 - bx_n)$ until convergence
  \item Result: $a/b \approx a \times x_n$
\end{enumerate}

\textbf{Example}: Compute $7/3$

\begin{itemize}
  \item Find $1/3$ first using $b = 3$
  \item $x_0 = 0.3$ (initial guess)
  \item $x_1 = 0.3(2 - 3 \times 0.3) = 0.3(2 - 0.9) = 0.33$
  \item $x_2 = 0.33(2 - 3 \times 0.33) = 0.33(2 - 0.99) = 0.3333$
  \item Then: $7/3 = 7 \times 0.3333\ldots \approx 2.333\ldots$
\end{itemize}

\begin{successbox}
This method avoids hardware division circuits entirely, using only multiplication and subtraction!
\end{successbox}

\section{Summary}

\subsection{Key Takeaways}

\begin{enumerate}
  \item \textbf{Integer Representation}: Two's complement is the standard due to its simplicity and no duplicate zero
  
  \item \textbf{IEEE-754 Floating-Point}: Understanding the bit layout (sign, exponent, mantissa) is crucial for:
  \begin{itemize}
    \item Recognizing representable numbers
    \item Understanding rounding behavior
    \item Identifying subnormal numbers
  \end{itemize}
  
  \item \textbf{Double Rounding Problem}: Demonstrates that rounding precision matters and can affect final results
  
  \item \textbf{Newton-Raphson}:
  \begin{itemize}
    \item Quadratic convergence (bits double each iteration)
    \item Can be adapted for both square root and division
    \item Division method avoids hardware division circuits
  \end{itemize}
\end{enumerate}

\subsection{Important Formulas}

\textbf{Square Root}:
\begin{equation}
x_{n+1} = \frac{1}{2}\left(x_n + \frac{a}{x_n}\right)
\end{equation}

\textbf{Division} (computing $1/b$):
\begin{equation}
x_{n+1} = x_n(2 - bx_n)
\end{equation}

\vspace{1cm}
\hrule
\vspace{0.5cm}
\noindent\textit{Tutorial solved with Claude by Giulia Lionetti  - Sorbonne Université}

\end{document}